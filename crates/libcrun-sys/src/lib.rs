// FFI bindings to libcrun
// Generated by bindgen from wrapper.h

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

/// Thread-safe wrapper for libcrun context pointer
/// 
/// # Safety
/// This wrapper is safe because libcrun context operations are thread-safe
/// and access is synchronized through the containing struct's RwLock.
#[derive(Debug)]
pub struct LibcrunContextPtr(pub *mut libcrun_context_t);

unsafe impl Send for LibcrunContextPtr {}
unsafe impl Sync for LibcrunContextPtr {}

impl LibcrunContextPtr {
    pub fn new(ptr: *mut libcrun_context_t) -> Self {
        Self(ptr)
    }
    
    pub fn as_ptr(&self) -> *mut libcrun_context_t {
        self.0
    }
    
    pub fn is_null(&self) -> bool {
        self.0.is_null()
    }
}

/// Thread-safe wrapper for libcrun container pointer
/// 
/// # Safety
/// This wrapper is safe because libcrun container operations are thread-safe
/// and access is synchronized through the containing struct's RwLock.
#[derive(Debug)]
pub struct LibcrunContainerPtr(pub *mut libcrun_container_t);

unsafe impl Send for LibcrunContainerPtr {}
unsafe impl Sync for LibcrunContainerPtr {}

impl LibcrunContainerPtr {
    pub fn new(ptr: *mut libcrun_container_t) -> Self {
        Self(ptr)
    }
    
    pub fn as_ptr(&self) -> *mut libcrun_container_t {
        self.0
    }
    
    pub fn is_null(&self) -> bool {
        self.0.is_null()
    }
}

// Safe wrappers around the FFI functions
pub mod safe {
    use super::*;
    use std::ffi::CString;
    use std::os::raw::c_int;
    use std::ptr;

    /// Error type for libcrun operations
    #[derive(Debug)]
    pub struct CrunError {
        pub code: i32,
        pub message: String,
    }

    impl CrunError {
        fn from_libcrun_error(err: *mut libcrun_error_t) -> Option<Self> {
            if err.is_null() {
                return None;
            }
            // In a real implementation, extract error message from libcrun_error_t
            // For now, return a generic error
            Some(CrunError {
                code: -1,
                message: "libcrun error".to_string(),
            })
        }
    }

    /// Create a new libcrun context
    pub fn context_new() -> Result<*mut libcrun_context_t, CrunError> {
        let mut err: *mut libcrun_error_t = ptr::null_mut();
        let context = libcrun_context_new(&mut err);

        if context.is_null() {
            if let Some(e) = CrunError::from_libcrun_error(err) {
                libcrun_error_release(&mut err);
                return Err(e);
            }
            return Err(CrunError {
                code: -1,
                message: "Failed to create libcrun context".to_string(),
            });
        }

        if !err.is_null() {
            libcrun_error_release(&mut err);
        }

        Ok(context)
    }

    /// Free a libcrun context
    pub fn context_free(context: *mut libcrun_context_t) {
        if !context.is_null() {
            libcrun_context_free(context);
        }
    }

    /// Load a container from JSON configuration
    pub fn container_load_from_memory(
        config_json: &str,
    ) -> Result<*mut libcrun_container_t, CrunError> {
        let config_cstr = CString::new(config_json).map_err(|_| CrunError {
            code: -1,
            message: "Invalid JSON string".to_string(),
        })?;

        let mut err: *mut libcrun_error_t = ptr::null_mut();
        let container = libcrun_container_load_from_memory(config_cstr.as_ptr(), &mut err);

        if container.is_null() {
            if let Some(e) = CrunError::from_libcrun_error(err) {
                libcrun_error_release(&mut err);
                return Err(e);
            }
            return Err(CrunError {
                code: -1,
                message: "Failed to load container from JSON".to_string(),
            });
        }

        if !err.is_null() {
            libcrun_error_release(&mut err);
        }

        Ok(container)
    }

    /// Free a container
    pub fn container_free(container: *mut libcrun_container_t) {
        if !container.is_null() {
            libcrun_container_free(container);
        }
    }

    /// Create a container
    pub fn container_create(
        context: *mut libcrun_context_t,
        container: *mut libcrun_container_t,
        id: &str,
    ) -> Result<(), CrunError> {
        let id_cstr = CString::new(id).map_err(|_| CrunError {
            code: -1,
            message: "Invalid container ID".to_string(),
        })?;

        let mut err: *mut libcrun_error_t = ptr::null_mut();
        let result = libcrun_container_create(context, container, id_cstr.as_ptr(), &mut err);

        if result != 0 {
            if let Some(e) = CrunError::from_libcrun_error(err) {
                libcrun_error_release(&mut err);
                return Err(e);
            }
            return Err(CrunError {
                code: result,
                message: format!("Failed to create container: {}", id),
            });
        }

        if !err.is_null() {
            libcrun_error_release(&mut err);
        }

        Ok(())
    }

    /// Start a container
    pub fn container_start(
        context: *mut libcrun_context_t,
        container: *mut libcrun_container_t,
        id: &str,
    ) -> Result<(), CrunError> {
        let id_cstr = CString::new(id).map_err(|_| CrunError {
            code: -1,
            message: "Invalid container ID".to_string(),
        })?;

        let mut err: *mut libcrun_error_t = ptr::null_mut();
        let result = libcrun_container_start(context, container, id_cstr.as_ptr(), &mut err);

        if result != 0 {
            if let Some(e) = CrunError::from_libcrun_error(err) {
                libcrun_error_release(&mut err);
                return Err(e);
            }
            return Err(CrunError {
                code: result,
                message: format!("Failed to start container: {}", id),
            });
        }

        if !err.is_null() {
            libcrun_error_release(&mut err);
        }

        Ok(())
    }

    /// Kill (stop) a container
    pub fn container_kill(
        context: *mut libcrun_context_t,
        container: *mut libcrun_container_t,
        id: &str,
        signal: c_int,
    ) -> Result<(), CrunError> {
        let id_cstr = CString::new(id).map_err(|_| CrunError {
            code: -1,
            message: "Invalid container ID".to_string(),
        })?;

        let mut err: *mut libcrun_error_t = ptr::null_mut();
        let result =
            libcrun_container_kill(context, container, id_cstr.as_ptr(), signal, &mut err);

        if result != 0 {
            if let Some(e) = CrunError::from_libcrun_error(err) {
                libcrun_error_release(&mut err);
                return Err(e);
            }
            return Err(CrunError {
                code: result,
                message: format!("Failed to kill container: {}", id),
            });
        }

        if !err.is_null() {
            libcrun_error_release(&mut err);
        }

        Ok(())
    }

    /// Delete a container
    pub fn container_delete(
        context: *mut libcrun_context_t,
        container: *mut libcrun_container_t,
        id: &str,
    ) -> Result<(), CrunError> {
        let id_cstr = CString::new(id).map_err(|_| CrunError {
            code: -1,
            message: "Invalid container ID".to_string(),
        })?;

        let mut err: *mut libcrun_error_t = ptr::null_mut();
        let result = libcrun_container_delete(context, container, id_cstr.as_ptr(), &mut err);

        if result != 0 {
            if let Some(e) = CrunError::from_libcrun_error(err) {
                libcrun_error_release(&mut err);
                return Err(e);
            }
            return Err(CrunError {
                code: result,
                message: format!("Failed to delete container: {}", id),
            });
        }

        if !err.is_null() {
            libcrun_error_release(&mut err);
        }

        Ok(())
    }

    /// Get container state
    pub fn container_state(
        context: *mut libcrun_context_t,
        container: *mut libcrun_container_t,
        id: &str,
    ) -> Result<(), CrunError> {
        let id_cstr = CString::new(id).map_err(|_| CrunError {
            code: -1,
            message: "Invalid container ID".to_string(),
        })?;

        let mut err: *mut libcrun_error_t = ptr::null_mut();
        let result = libcrun_container_state(context, container, id_cstr.as_ptr(), &mut err);

        if result != 0 {
            if let Some(e) = CrunError::from_libcrun_error(err) {
                libcrun_error_release(&mut err);
                return Err(e);
            }
            return Err(CrunError {
                code: result,
                message: format!("Failed to get container state: {}", id),
            });
        }

        if !err.is_null() {
            libcrun_error_release(&mut err);
        }

        Ok(())
    }

    /// Get container PID by reading from state file
    /// This is a fallback method when container_state doesn't provide PID directly
    pub fn get_container_pid(id: &str) -> Option<u32> {
        use std::fs;
        use std::path::PathBuf;

        // Try common locations for crun state files
        let state_paths = vec![
            PathBuf::from(format!("/run/crun/{}", id)),
            PathBuf::from(format!("/run/crun/{}/state.json", id)),
            PathBuf::from(format!("/var/run/crun/{}", id)),
            PathBuf::from(format!("/var/run/crun/{}/state.json", id)),
        ];

        for path in state_paths {
            if path.is_file() {
                // Try to read and parse JSON state file
                if let Ok(content) = fs::read_to_string(&path) {
                    if let Ok(json) = serde_json::from_str::<serde_json::Value>(&content) {
                        // Try different possible JSON structures
                        if let Some(pid) = json
                            .get("pid")
                            .or_else(|| json.get("init_process_pid"))
                            .or_else(|| json.get("state").and_then(|s| s.get("pid")))
                        {
                            if let Some(pid_num) = pid.as_u64() {
                                return Some(pid_num as u32);
                            }
                        }
                    }
                }
            } else if path.is_dir() {
                // Try state.json in the directory
                let state_file = path.join("state.json");
                if state_file.exists() {
                    if let Ok(content) = fs::read_to_string(&state_file) {
                        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&content) {
                            if let Some(pid) = json
                                .get("pid")
                                .or_else(|| json.get("init_process_pid"))
                                .or_else(|| json.get("state").and_then(|s| s.get("pid")))
                            {
                                if let Some(pid_num) = pid.as_u64() {
                                    return Some(pid_num as u32);
                                }
                            }
                        }
                    }
                }
            }
        }

        None
    }
}
